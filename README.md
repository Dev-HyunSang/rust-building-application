# rust-building-application
[Rust : 실제 애플리케이션 구축을 통한 Rust 완벽 정복](https://kmooc.udemy.com/course/rust-building-application)를 통해서 공부하고 있습니다.

## Table of Contents
- [rust-building-application](#rust-building-application)
  - [Table of Contents](#table-of-contents)
  - [Q\&A](#qa)
    - [Rust언어에서 mut가 뜻하는 게 뭐야?](#rust언어에서-mut가-뜻하는-게-뭐야)
    - [Rust언어에서 소유권 규칙을 알려줘.](#rust언어에서-소유권-규칙을-알려줘)
    - [이중해제 취약점](#이중해제-취약점)
  - [공부하면서 참고한 자료들](#공부하면서-참고한-자료들)

## Q&A
ChatGPT를 통해서! 공부하면서 궁금한 점을 해결하고 있습니다.

### Rust언어에서 mut가 뜻하는 게 뭐야?
Rust 언어에서 mut는 "mutable"을 나타내는 키워드입니다. 변수 선언 시 mut 키워드를 사용하면 해당 변수는 가변(mutable) 변수가 됩니다. 즉, 값을 변경할 수 있는 변수를 선언하는 것을 의미합니다.

Rust는 기본적으로 변수가 불변(immutable)으로 선언되어 있으며, 값을 변경하려면 변수를 가변으로 선언해야 합니다. 가변 변수를 사용하면 해당 변수의 값을 변경할 수 있으며, 이는 Rust의 소유권(ownership) 시스템과 빌더 패턴(builder pattern)의 일부와 관련이 있습니다.

다음은 mut를 사용하여 가변 변수를 선언하는 예시입니다:
```rust
fn main() {
    let mut x = 5; // 가변 변수 x 선언
    println!("x: {}", x); // x: 5

    x = 10; // 변수 x의 값을 변경
    println!("x: {}", x); // x: 10
}
```

### Rust언어에서 소유권 규칙을 알려줘.
위 예시에서 x 변수는 mut 키워드로 선언되었기 때문에 값을 변경할 수 있습니다. 첫 번째 println! 매크로 호출 이후에 x 값을 10으로 변경하고 두 번째 println! 매크로 호출에서 변경된 값이 출력됩니다.

Rust 언어에서는 소유권(ownership) 규칙이라는 중요한 개념을 가지고 있습니다. 이 규칙은 Rust의 메모리 안전성을 보장하고, 데이터 경합 문제나 댈러스틱 메모리 관리를 방지하는 데 도움을 줍니다. 소유권 규칙은 다음과 같이 요약할 수 있습니다:

각 값은 오직 하나의 소유자(Owner)만 가질 수 있습니다.
소유자가 범위(scope)를 벗어나면 해당 값은 자동으로 해제됩니다.
값은 오직 소유자를 통해서만 접근할 수 있습니다.
이 규칙을 통해 Rust는 다음과 같은 장점을 가집니다:

데이터 경합 문제를 컴파일 시간에 잡아냄: 동시에 여러 스레드에서 데이터에 접근하는 경우, Rust는 소유권 규칙을 통해 데이터 경합 문제를 사전에 방지할 수 있습니다.
댈러스틱 메모리 관리 방지: Rust는 소유권 규칙을 통해 메모리 할당과 해제를 정확하게 추적하여 댈러스틱 메모리 관리 문제를 방지합니다. 이를 통해 메모리 누수나 무효한 포인터 문제를 사전에 방지할 수 있습니다.
복사보다 이동(move)을 선호: 소유권 규칙은 값의 이동(move)을 강제함으로써 복사보다 효율적인 메모리 관리를 가능하게 합니다.
이 규칙은 Rust의 핵심 원칙이며, 개발자는 이를 이해하고 코드를 작성해야 합니다. Rust 컴파일러는 이러한 규칙을 검사하여 소유권 규칙을 준수하지 않는 코드를 컴파일 시간에 에러로 표시합니다.

---

[The Rust Programming Language - 소유권 이해하기](https://rinthel.github.io/rust-lang-book-ko/ch04-00-understanding-ownership.html)를 참고하면 좋아요!

### 이중해제 취약점

이중 해제 취약점(Double Free Vulnerability)은 프로그래밍에서 발생하는 메모리 관리 취약점 중 하나입니다. 이 취약점은 메모리 할당 및 해제 과정에서 발생할 수 있습니다.

일반적으로, 프로그램에서 동적으로 할당한 메모리는 사용이 완료되면 명시적으로 해제해야 합니다. 이때, 이중 해제 취약점은 같은 메모리 주소를 두 번 해제하는 상황을 의미합니다. 이는 메모리 할당자에게 모순된 명령을 제공하고, 프로그램의 예측 불가능한 동작을 유발할 수 있습니다.

일반적으로 이중 해제 취약점은 다음과 같은 과정에서 발생할 수 있습니다:

메모리 할당: 프로그램이 동적으로 메모리를 할당합니다. 이때 할당된 메모리 영역은 사용되는 동안에는 다른 부분에 할당되지 않아야 합니다.

메모리 해제: 할당된 메모리를 사용한 후, 명시적으로 해제해야 합니다. 이 단계에서 이미 해제된 메모리를 다시 해제하는 경우, 이중 해제 취약점이 발생합니다.

재사용: 이미 해제된 메모리 영역을 다시 사용하려고 할 때, 문제가 발생할 수 있습니다. 해제된 메모리를 다시 사용하는 것은 메모리 할당자의 결정에 따라 다르지만, 이는 이중 해제 취약점을 악용할 수 있는 기회를 제공합니다.

이중 해제 취약점은 프로그램의 안정성과 보안을 악화시킬 수 있습니다. 해제된 메모리를 다시 사용하려는 시도는 사용되지 않은 메모리 영역에 접근하는 문제를 일으킬 수 있으며, 악의적인 공격자가 해당 취약점을 이용하여 프로그램의 실행 흐름을 조작하거나 메모리 누수를 악용할 수 있습니다.

이러한 이중 해제 취약점을 방지하기 위해서는 메모리 할당과 해제를 정확하게 관리해야 합니다. 할당된 메모리를 해제한 후에는 해당 메모리에 대한 포인터를 삭제하거나 초기화해야 하며, 재사용할 때는 할당된 메모리에 대한 포인터가 유효한지 검사해야 합니다. 또한, 메모리 할당 및 해제와 관련된 안전한 프로그래밍 패턴과

라이브러리를 사용하는 것이 중요합니다.

## 공부하면서 참고한 자료들
- **RAII 관련:**
  - [RAII는 무엇인가](https://blog.seulgi.kim/2014/01/raii.html)
  - [Rust Example - RAII](https://doc.rust-lang.org/rust-by-example/scope/raii.html)